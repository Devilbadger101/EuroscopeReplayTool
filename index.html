<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EuroScope Replay Viewer</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Three.js for volumetric 3D radar -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

  <style>
    :root {
      --bg-dark: #020617;
      --bg-panel: rgba(15, 23, 42, 0.88);
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.16);
      --accent-strong: #a5b4fc;
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --border-subtle: rgba(148, 163, 184, 0.4);
      --radius-lg: 999px;
      --radius-md: 14px;
      --shadow-soft: 0 20px 50px rgba(0, 0, 0, 0.75);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background:
        radial-gradient(circle at top, rgba(56, 189, 248, 0.08), transparent 55%),
        radial-gradient(circle at bottom, rgba(79, 70, 229, 0.2), #020617);
      color: var(--text-main);
      overflow: hidden;
    }

    #map {
      position: absolute;
      inset: 0;
    }

    /* --- Main control dock --- */
    #toolbar {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
      padding: 10px 12px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.92));
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(148, 163, 184, 0.5);
      backdrop-filter: blur(22px) saturate(140%);
      max-width: min(1150px, 96vw);
    }

    .toolbar-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .toolbar-title {
      font-weight: 600;
      letter-spacing: 0.08em;
      font-size: 11px;
      text-transform: uppercase;
      color: var(--accent-strong);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px 2px 4px;
      border-radius: 999px;
      background: radial-gradient(circle at left, rgba(34, 197, 94, 0.16), transparent 55%);
    }

    .toolbar-title-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: radial-gradient(circle, #22c55e, #16a34a);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.35);
    }

    .toolbar-mode-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      padding: 3px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-muted);
    }

    .toolbar-mode-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
    }

    .toolbar-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 8px;
      margin-top: 4px;
    }

    .card {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      border-radius: var(--radius-md);
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(31, 41, 55, 0.9);
    }

    .card-header {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card-header span.label-pill {
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent-strong);
      font-size: 10px;
      font-weight: 500;
    }

    .card-body {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    #fileInput { display: none; }

    .file-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle at top left, rgba(30, 64, 175, 0.5), rgba(15, 23, 42, 0.95));
      color: var(--text-main);
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
    }

    .file-label span.badge {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 10px;
      color: var(--text-muted);
    }

    .file-label-icon {
      width: 14px;
      height: 14px;
      border-radius: 6px;
      border: 1px solid rgba(209, 213, 219, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
    }

    button {
      padding: 6px 12px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-main);
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
      white-space: nowrap;
    }

    button.primary {
      background: radial-gradient(circle at top left, #6366f1, #4f46e5);
      border-color: rgba(191, 219, 254, 0.9);
      box-shadow: 0 0 0 1px rgba(129, 140, 248, 0.45);
    }

    button.primary:hover:not(:disabled) {
      background: radial-gradient(circle at top left, #4f46e5, #4338ca);
    }

    button:hover:not(:disabled) {
      background: rgba(15, 23, 42, 1);
      border-color: rgba(148, 163, 184, 0.9);
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.45;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    label.inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .alt-input {
      width: 76px;
      background: rgba(15, 23, 42, 0.98);
      border: 1px solid var(--border-subtle);
      color: var(--text-main);
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 11px;
      outline: none;
    }

    .alt-input:focus {
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 1px rgba(129, 140, 248, 0.6);
    }

    .color-input {
      width: 40px;
      padding: 0;
      height: 22px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: transparent;
      cursor: pointer;
    }

    #speedRange, #timelineRange {
      accent-color: var(--accent);
    }

    #speedRange {
      width: 110px;
    }

    #timelineRange {
      flex: 1;
    }

    .speed-label {
      font-size: 11px;
      color: var(--accent-strong);
      min-width: 40px;
      text-align: right;
    }

    .subtext {
      font-size: 10px;
      color: var(--text-muted);
    }

    #controlsToggle {
      position: absolute;
      top: 14px;
      right: 14px;
      z-index: 11;
      padding: 6px 10px;
      border-radius: var(--radius-lg);
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.5);
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
    }

    #controlsToggleIcon {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #22c55e;
    }

    @media (max-width: 900px) {
      #toolbar {
        bottom: 10px;
        padding: 8px 9px;
        border-radius: 16px;
      }
      .toolbar-grid {
        grid-template-columns: 1fr;
      }
      #controlsToggle {
        top: auto;
        bottom: 10px;
        right: 10px;
      }
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #9ca3af;
    }
    .dot.paused { background: #f97316; }
    .dot.stopped { background: #4b5563; }

    /* View buttons as a segmented group */
    .view-toggle-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .view-toggle {
      font-size: 11px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-muted);
    }

    .view-toggle.active {
      background: var(--accent-soft);
      border-color: var(--accent-strong);
      color: var(--accent-strong);
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <!-- Controls visibility toggle -->
  <button id="controlsToggle">
    <span id="controlsToggleIcon"></span>
    <span id="controlsToggleText">Hide controls</span>
  </button>

  <div id="toolbar">
    <div class="toolbar-header-row">
      <div class="toolbar-title">
        <span class="toolbar-title-dot"></span>
        <span>EuroScope Replay</span>
      </div>
      <div class="toolbar-mode-pill">
        <span class="toolbar-mode-dot"></span>
        <span id="replayStatusLabel">Idle</span>
      </div>
    </div>

    <div class="toolbar-grid">
      <!-- Replay card -->
      <div class="card">
        <div class="card-header">
          <span>Replay</span>
          <span class="label-pill">Playback</span>
        </div>
        <div class="card-body">
          <label for="fileInput" class="file-label">
            <span class="file-label-icon">‚¨Ü</span>
            <span>Load Euroscope log</span>
            <span class="badge">.txt / .log</span>
          </label>
          <input type="file" id="fileInput" accept=".txt,.log" />

          <button id="playPause" class="primary" disabled>
            <span class="dot stopped" id="playPauseDot"></span>
            <span id="playPauseText">Pause</span>
          </button>

          <label class="inline">
            Speed
            <input type="range" id="speedRange" min="0.25" max="16" step="0.25" value="4" />
            <span class="speed-label" id="speedLabel">4x</span>
          </label>

          <label class="inline" style="flex:1 1 100%; margin-top:2px;">
            Timeline
            <input type="range" id="timelineRange" min="0" max="0" step="1" value="0" disabled />
            <span class="speed-label" id="timelineLabel">0 / 0</span>
          </label>
        </div>
      </div>

      <!-- Altitude filters -->
      <div class="card">
        <div class="card-header">
          <span>Filters</span>
          <span class="label-pill">Altitude</span>
        </div>
        <div class="card-body">
          <label class="inline">
            Min (ft)
            <input id="minAlt" class="alt-input" type="number" value="0" />
          </label>
          <label class="inline">
            Max (ft)
            <input id="maxAlt" class="alt-input" type="number" value="45000" />
          </label>
          <button id="applyAlt">Apply</button>
          <span class="subtext">Filter aircraft and trails by altitude.</span>
        </div>
      </div>

      <!-- Universal view controls -->
      <div class="card">
        <div class="card-header">
          <span>View</span>
          <span class="label-pill">Global</span>
        </div>
        <div class="card-body">
          <div class="view-toggle-group">
            <button id="btnViewDark" class="view-toggle active">üåë Dark</button>
            <button id="btnViewSatellite" class="view-toggle">üõ∞ Satellite</button>
            <button id="btnViewUnlabeled" class="view-toggle">üó∫ Dark unlabeled</button>
          </div>
          <span class="subtext" style="flex:1 1 100%;">Applies to both 2D &amp; 3D modes.</span>
        </div>
      </div>

      <!-- Trails card -->
      <div class="card">
        <div class="card-header">
          <span>Trails</span>
          <span class="label-pill">2D &amp; 3D</span>
        </div>
        <div class="card-body">
          <label class="inline">
            Length
            <input id="trailLengthNm" class="alt-input" type="number" value="30" />
            <span style="font-size:10px;color:var(--text-muted);margin-left:2px;">NM</span>
          </label>
          <button id="applyTrailLength">Set</button>

          <button id="keepAllTrailsBtn">
            ‚ôæÔ∏è <span id="keepAllTrailsText">Keep all trails</span>
          </button>

          <label class="inline">
            Colour
            <input id="trailColor" type="color" value="#eab308" class="color-input" />
          </label>

          <span class="subtext">
            Trail length &amp; colour apply to both 2D trails and 3D trails.
          </span>
        </div>
      </div>

      <!-- 2D view controls -->
      <div class="card">
        <div class="card-header">
          <span>2D View</span>
          <span class="label-pill">Icons &amp; trails</span>
        </div>
        <div class="card-body">
          <button id="toggleTrails">
            üßµ <span id="toggleTrailsText">Hide trails</span>
          </button>

          <button id="toggleHideIcons">
            üö´‚úàÔ∏è <span id="toggleHideIconsText">Hide icons: off</span>
          </button>

          <span class="subtext">
            2D mode: flat map with aircraft icons &amp; 2D trails.
          </span>
        </div>
      </div>

      <!-- 3D view controls -->
      <div class="card">
        <div class="card-header">
          <span>3D View</span>
          <span class="label-pill">Cones &amp; 3D trails</span>
        </div>
        <div class="card-body">
          <button id="toggle3DView">
            üó∫ <span id="toggle3DViewText">3D mode</span>
          </button>
          <span class="subtext">
            3D mode shows volumetric cones &amp; 3D trails. 2D icons/trails are hidden in 3D.
          </span>
        </div>
      </div>
    </div>
  </div>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoiZGV2aWxiYWRnZXIxMDEiLCJhIjoiY21rMGF0YzRpMGl1NDNmc2lpMHFrcWwxcCJ9.yARs0JW8w1TOCFXRT-UGoQ';

    // Themes
    const THEME = {
      DARK: 'dark',
      SATELLITE: 'satellite',
      UNLABELED: 'unlabeled'
    };

    // Default theme: dark
    let currentTheme = THEME.DARK;
    let currentBaseStyleUrl = 'mapbox://styles/mapbox/dark-v11';

    const map = new mapboxgl.Map({
      container: 'map',
      style: currentBaseStyleUrl,
      center: [-2.5, 53.0],
      zoom: 6,
      pitch: 60,
      bearing: -24,
      antialias: true
    });

    // === Three.js volumetric radar layer ===
    const threeLayer = {
      id: 'three-radar',
      type: 'custom',
      renderingMode: '3d',

      onAdd(map, gl) {
        this.map = map;

        this.renderer = new THREE.WebGLRenderer({
          canvas: map.getCanvas(),
          context: gl,
          antialias: true
        });
        this.renderer.autoClear = false;

        this.scene = new THREE.Scene();
        this.camera = new THREE.Camera();

        const ambient = new THREE.AmbientLight(0xffffff, 0.9);
        this.scene.add(ambient);

        this.aircraftObjects = new Map();
        this.trailLines = new Map();

        this.createAircraftMesh = function(callsign) {
          const geometry = new THREE.ConeGeometry(10, 40, 8);
          const material = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
          const mesh = new THREE.Mesh(geometry, material);

          mesh.rotation.x = Math.PI / 2; // nose along +Y
          this.scene.add(mesh);
          this.aircraftObjects.set(callsign, mesh);
          return mesh;
        };

        this.createTrailLine = function(callsign) {
          const geometry = new THREE.BufferGeometry();
          const material = new THREE.LineBasicMaterial({
            transparent: true,
            opacity: 1.0,
            vertexColors: true // per-vertex colors for gradient
          });
          const line = new THREE.Line(geometry, material);
          this.scene.add(line);
          this.trailLines.set(callsign, line);
          return line;
        };
      },

      render(gl, matrix) {
        if (!this.scene) return;

        const m = new THREE.Matrix4().fromArray(matrix);
        this.camera.projectionMatrix = m;

        this.renderer.state.reset();
        this.renderer.render(this.scene, this.camera);

        this.map.triggerRepaint();
      }
    };

    // Global replay state
    let frames = [];
    let aircraftTypes = {};
    let aircraftFeatures = {};
    let trailFeatures = {};
    let aircraftLastSeen = {};
    let replayIndex = 0;
    let maxFrames = 0;
    let animationRunning = false;
    let isPaused = false;

    const MIN_POINT_SPACING_NM = 0.2;
    const DESPAWN_FRAMES = 250;
    const TRAIL_FADE_STEP_NM_GS0 = 0.01;
    const TRAIL_FADE_STEP_NM_TIMEOUT = 0.01;
    const STOP_FRAMES_BEFORE_FADE = 250;

    let maxTrailHistoryNm = 30;
    let trailsVisible = true;
    let playbackSpeed = 4.0;
    let is3DView = true;    // 3D mode by default
    let controlsVisible = true;
    let keepAllTrails = false;
    let hideIcons = false;

    let minAlt = 0;
    let maxAlt = 45000;
    let mapInitializedOnce = false;
    let trailColor = '#eab308';

    // GS=0 tracking: callsign -> frameIndex when it first hit GS=0
    let stoppedSinceFrame = {};

    // Render throttling
    let needsRender = false;
    let lastRenderTime = 0;
    const RENDER_INTERVAL_MS = 50;

    // Single icon config
    const ICON_BASE_PATH = './icons/aircraft';
    const ICON_GENERIC_ID = 'aircraft-a320';
    const ICON_GENERIC_FILE = 'a320.svg';

    // Simple replay state constants
    const REPLAY_STATE = {
      IDLE: 'idle',
      PLAYING: 'playing',
      PAUSED: 'paused'
    };

    // Cached GeoJSON references (centralised updates)
    let lastAircraftGeoJSON = null;
    let lastTrailsGeoJSON = null;

    function getAircraftGeoJSON() {
      return {
        type: 'FeatureCollection',
        features: Object.values(aircraftFeatures)
      };
    }

    function getTrailsGeoJSON() {
      return {
        type: 'FeatureCollection',
        features: Object.values(trailFeatures)
      };
    }

    function updateMapSources() {
      const aircraftSource = map.getSource('aircraft');
      const trailsSource = map.getSource('trails');

      if (aircraftSource) {
        const data = getAircraftGeoJSON();
        aircraftSource.setData(data);
        lastAircraftGeoJSON = data;
      }

      if (trailsSource) {
        const data = getTrailsGeoJSON();
        trailsSource.setData(data);
        lastTrailsGeoJSON = data;
      }
    }

    function loadPlaneIcon() {
      if (map.hasImage(ICON_GENERIC_ID)) return;

      const url = `${ICON_BASE_PATH}/${ICON_GENERIC_FILE}`;
      const img = new Image();
      img.onload = () => {
        try {
          if (!map.hasImage(ICON_GENERIC_ID)) {
            map.addImage(ICON_GENERIC_ID, img, { pixelRatio: 2 });
          }
        } catch (e) {
          console.error('map.addImage failed for', ICON_GENERIC_ID, e);
        }
      };
      img.onerror = () => {
        console.warn('Failed to load aircraft icon from', url);
      };
      img.src = url;
    }

    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex || '');
      if (!m) return { r: 234, g: 179, b: 8 };
      return {
        r: parseInt(m[1], 16),
        g: parseInt(m[2], 16),
        b: parseInt(m[3], 16)
      };
    }

    function buildTrailGradient(colorHex) {
      const { r, g, b } = hexToRgb(colorHex);
      return [
        'interpolate',
        ['linear'],
        ['line-progress'],
        0.0, ['rgba', r, g, b, 0.0],
        0.4, ['rgba', r, g, b, 0.4],
        1.0, ['rgba', r, g, b, 1.0]
      ];
    }

    function updateTrailColor() {
      if (!map.getLayer('trail-layer')) return;
      map.setPaintProperty('trail-layer', 'line-gradient', buildTrailGradient(trailColor));
    }

    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const playPauseBtn = document.getElementById('playPause');
    const playPauseText = document.getElementById('playPauseText');
    const playPauseDot = document.getElementById('playPauseDot');
    const speedRange = document.getElementById('speedRange');
    const speedLabel = document.getElementById('speedLabel');
    const toggleTrailsBtn = document.getElementById('toggleTrails');
    const toggleTrailsText = document.getElementById('toggleTrailsText');
    const toggle3DViewBtn = document.getElementById('toggle3DView');
    const toggle3DViewText = document.getElementById('toggle3DViewText');
    const keepAllTrailsBtn = document.getElementById('keepAllTrailsBtn');
    const keepAllTrailsText = document.getElementById('keepAllTrailsText');
    const toggleHideIconsBtn = document.getElementById('toggleHideIcons');
    const toggleHideIconsText = document.getElementById('toggleHideIconsText');
    const trailLengthInput = document.getElementById('trailLengthNm');
    const applyTrailLengthBtn = document.getElementById('applyTrailLength');
    const minAltInput = document.getElementById('minAlt');
    const maxAltInput = document.getElementById('maxAlt');
    const applyAltBtn = document.getElementById('applyAlt');
    const replayStatusLabel = document.getElementById('replayStatusLabel');
    const toolbar = document.getElementById('toolbar');
    const controlsToggle = document.getElementById('controlsToggle');
    const controlsToggleIcon = document.getElementById('controlsToggleIcon');
    const controlsToggleText = document.getElementById('controlsToggleText');
    const trailColorInput = document.getElementById('trailColor');
    const timelineRange = document.getElementById('timelineRange');
    const timelineLabel = document.getElementById('timelineLabel');
    const btnViewDark = document.getElementById('btnViewDark');
    const btnViewSatellite = document.getElementById('btnViewSatellite');
    const btnViewUnlabeled = document.getElementById('btnViewUnlabeled');
    let isScrubbing = false;

    function setStatus(state, text) {
      playPauseDot.classList.remove('paused', 'stopped');

      switch (state) {
        case REPLAY_STATE.IDLE:
          playPauseDot.classList.add('stopped');
          replayStatusLabel.textContent = 'Idle';
          break;
        case REPLAY_STATE.PLAYING:
          replayStatusLabel.textContent = 'Playing';
          break;
        case REPLAY_STATE.PAUSED:
          playPauseDot.classList.add('paused');
          replayStatusLabel.textContent = 'Paused';
          break;
      }
      // text kept for optional future UX/logging
    }

    function ftToMeters(ft) {
      return ft * 0.3048;
    }

    function computeBearing(lat1, lon1, lat2, lon2) {
      const œÜ1 = lat1 * Math.PI / 180;
      const œÜ2 = lat2 * Math.PI / 180;
      const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

      const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
      const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
      let Œ∏ = Math.atan2(y, x) * 180 / Math.PI;
      if (Œ∏ < 0) Œ∏ += 360;
      return Œ∏;
    }

    function distanceNm(lat1, lon1, lat2, lon2) {
      const R_nm = 3440.065;
      const œÜ1 = lat1 * Math.PI / 180;
      const œÜ2 = lat2 * Math.PI / 180;
      const dœÜ = (lat2 - lat1) * Math.PI / 180;
      const dŒª = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(dœÜ / 2) * Math.sin(dœÜ / 2) +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(dŒª / 2) * Math.sin(dŒª / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R_nm * c;
    }

    function getWakeCategory(icao) {
      if (!icao) return 'M';
      const t = icao.toUpperCase().trim();

      if (/^A38[0-9]$/.test(t)) return 'J';

      if (
        /^B74[0-9]$/.test(t) ||
        /^B77[0-9]$/.test(t) ||
        /^B78[0-9]$/.test(t) ||
        /^A33[0-9]$/.test(t) ||
        /^A34[0-9]$/.test(t) ||
        /^A35[0-9]$/.test(t) ||
        t === 'MD11' || t === 'DC10'
      ) {
        return 'H';
      }

      if (
        /^(C15|C16|C17|C18|C19|C152|C172|C182|C210|PA18|PA28|PA38|PA44|DV20|DV40|SR2|R22|R44|B06)/.test(t)
      ) {
        return 'L';
      }

      return 'M';
    }

    function ensureReplayLayers() {
      const hasAircraft = Object.keys(aircraftFeatures).length > 0;
      const hasTrails = Object.keys(trailFeatures).length > 0;

      if (hasAircraft && !map.getSource('aircraft')) {
        map.addSource('aircraft', {
          type: 'geojson',
          data: getAircraftGeoJSON()
        });

        map.addLayer({
          id: 'aircraft-layer',
          type: 'symbol',
          source: 'aircraft',
          layout: {
            'icon-image': ICON_GENERIC_ID,
            'icon-size': 0.09,
            'icon-rotate': ['get', 'heading'],
            'icon-rotation-alignment': 'map',
            'icon-allow-overlap': true,
            'icon-ignore-placement': true
          }
        });
      }

      if (hasTrails && !map.getSource('trails')) {
        map.addSource('trails', {
          type: 'geojson',
          lineMetrics: true,
          data: getTrailsGeoJSON()
        });

        map.addLayer({
          id: 'trail-layer',
          type: 'line',
          source: 'trails',
          layout: {
            'line-join': 'round',
            'line-cap': 'round'
          },
          paint: {
            'line-width': 2,
            'line-opacity': 0.9,
            'line-gradient': buildTrailGradient(trailColor)
          }
        });
      }

      applyHideIconsVisualState();
    }

    function applyAltitudeFilter() {
      const filter = [
        "all",
        [">=", ["to-number", ["get", "alt_ft"]], minAlt],
        ["<=", ["to-number", ["get", "alt_ft"]], maxAlt]
      ];

      if (map.getLayer('aircraft-layer')) {
        map.setFilter('aircraft-layer', filter);
      }
      if (map.getLayer('trail-layer')) {
        map.setFilter('trail-layer', filter);
      }
    }

    // Start fading a trail from the back, with reason (gs0 / timeout / other)
    function startTrailFade(callsign, reason) {
      const trail = trailFeatures[callsign];
      if (!trail) return;
      trail.properties = trail.properties || {};
      trail.properties.fading = true;
      trail.properties.fadeReason = reason || 'other';
    }

    function updateKeepAllTrailsButton() {
      keepAllTrailsText.textContent = keepAllTrails ? 'Limit trails' : 'Keep all trails';
    }

    // 2D overlays visibility (2D mode only)
    function applyHideIconsVisualState() {
      const aircraftVisibility = (!is3DView && !hideIcons) ? 'visible' : 'none';
      const trailVisibility    = (!is3DView && trailsVisible) ? 'visible' : 'none';

      if (map.getLayer('aircraft-layer')) {
        map.setLayoutProperty('aircraft-layer', 'visibility', aircraftVisibility);
      }
      if (map.getLayer('trail-layer')) {
        map.setLayoutProperty('trail-layer', 'visibility', trailVisibility);
        map.setPaintProperty('trail-layer', 'line-width', hideIcons ? 1.5 : 2);
        map.setPaintProperty('trail-layer', 'line-opacity', hideIcons ? 1.0 : 0.9);
      }
    }

    function updateTimelineUI() {
      if (!maxFrames) {
        timelineRange.min = 0;
        timelineRange.max = 0;
        timelineRange.value = 0;
        timelineLabel.textContent = '0 / 0';
        return;
      }
      timelineRange.min = 0;
      timelineRange.max = maxFrames - 1;
      if (!isScrubbing) {
        timelineRange.value = replayIndex;
      }
      timelineLabel.textContent = `${replayIndex} / ${maxFrames - 1}`;
    }

    function clearReplayVisualState() {
      aircraftFeatures = {};
      trailFeatures = {};
      aircraftLastSeen = {};
      stoppedSinceFrame = {};

      if (threeLayer.scene) {
        threeLayer.aircraftObjects.forEach(mesh => {
          threeLayer.scene.remove(mesh);
          mesh.geometry.dispose();
          mesh.material.dispose();
        });
        threeLayer.aircraftObjects.clear();

        threeLayer.trailLines.forEach((line) => {
          threeLayer.scene.remove(line);
          line.geometry.dispose();
          line.material.dispose();
        });
        threeLayer.trailLines.clear();
      }
    }

    // 3D helpers: aircraft + trails
    function updateAircraftObjectForEvent(ev) {
      if (!threeLayer.scene || !is3DView) return;

      const { callsign, lat, lon, alt_ft, heading } = ev;

      let mesh = threeLayer.aircraftObjects.get(callsign);
      if (!mesh) {
        mesh = threeLayer.createAircraftMesh(callsign);
      }

      const altMeters = ftToMeters(alt_ft || 0);

      const merc = mapboxgl.MercatorCoordinate.fromLngLat(
        { lng: lon, lat: lat },
        altMeters
      );

      mesh.position.set(merc.x, merc.y, merc.z);

      if (!mesh.userData.meterScale) {
        const meterScale = merc.meterInMercatorCoordinateUnits();
        mesh.scale.set(meterScale, meterScale, meterScale);
        mesh.userData.meterScale = meterScale;
      }

      const yawRad = THREE.MathUtils.degToRad(heading || 0);
      mesh.rotation.z = -yawRad;
    }

    function updateTrailLineForCallsign(callsign) {
      if (!threeLayer.scene || !is3DView) return;

      const trail = trailFeatures[callsign];
      if (!trail) {
        const old = threeLayer.trailLines.get(callsign);
        if (old) {
          threeLayer.scene.remove(old);
          old.geometry.dispose();
          old.material.dispose();
          threeLayer.trailLines.delete(callsign);
        }
        return;
      }

      let line = threeLayer.trailLines.get(callsign);
      if (!line) {
        line = threeLayer.createTrailLine(callsign);
      }

      const coords = trail.geometry.coordinates;
      if (!coords || coords.length < 2) {
        threeLayer.scene.remove(line);
        line.geometry.dispose();
        line.material.dispose();
        threeLayer.trailLines.delete(callsign);
        return;
      }

      const positions = new Float32Array(coords.length * 3);
      const colors = new Float32Array(coords.length * 3);

      const { r, g, b } = hexToRgb(trailColor);
      const baseColor = new THREE.Color(`rgb(${r}, ${g}, ${b})`);

      for (let i = 0; i < coords.length; i++) {
        const [lon, lat, alt_m] = coords[i];
        const merc = mapboxgl.MercatorCoordinate.fromLngLat(
          { lng: lon, lat: lat },
          alt_m
        );

        positions[i * 3 + 0] = merc.x;
        positions[i * 3 + 1] = merc.y;
        positions[i * 3 + 2] = merc.z;

        const t = coords.length > 1 ? i / (coords.length - 1) : 1.0;
        const intensity = 0.25 + 0.75 * t; // darker tail, bright head
        const c = baseColor.clone().multiplyScalar(intensity);

        colors[i * 3 + 0] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }

      line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      line.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      line.geometry.computeBoundingSphere();
      line.material.needsUpdate = true;

      const alt_ft = (trail.properties && trail.properties.alt_ft) || 0;
      const inAltRange = alt_ft >= minAlt && alt_ft <= maxAlt;
      line.visible = is3DView && trailsVisible && inAltRange;
    }

    function rebuildAll3DGeometry() {
      if (!threeLayer.scene || !is3DView) return;

      // Rebuild aircraft meshes
      for (const cs in aircraftFeatures) {
        const f = aircraftFeatures[cs];
        const ev = {
          callsign: cs,
          lat: f.geometry.coordinates[1],
          lon: f.geometry.coordinates[0],
          alt_ft: f.properties.alt_ft || 0,
          heading: f.properties.heading || 0
        };
        updateAircraftObjectForEvent(ev);
      }

      // Rebuild 3D trails
      for (const cs in trailFeatures) {
        updateTrailLineForCallsign(cs);
      }
    }

    function update3DVisibility() {
      const show3D = is3DView;

      if (threeLayer && threeLayer.aircraftObjects) {
        threeLayer.aircraftObjects.forEach(mesh => {
          mesh.visible = show3D;
        });
      }

      if (threeLayer && threeLayer.trailLines) {
        threeLayer.trailLines.forEach((line, cs) => {
          const trail = trailFeatures[cs];
          if (!trail) {
            line.visible = false;
            return;
          }
          const alt_ft = (trail.properties && trail.properties.alt_ft) || 0;
          const inAltRange = alt_ft >= minAlt && alt_ft <= maxAlt;
          line.visible = show3D && trailsVisible && inAltRange;
        });
      }
    }

    // Apply one frame
    function applyFrameStep() {
      if (replayIndex >= maxFrames) return;

      const frameEvents = frames[replayIndex] || [];

      frameEvents.forEach(ev => {
        const { callsign, lat, lon, alt_ft, heading, gs_kt } = ev;
        let feature = aircraftFeatures[callsign];

        const hasValidSpeed = Number.isFinite(gs_kt);
        const isStopped = hasValidSpeed && gs_kt <= 0;

        if (!feature) {
          const icao = aircraftTypes[callsign] || '';
          const wakeCat = getWakeCategory(icao);

          feature = {
            type: 'Feature',
            properties: {
              callsign,
              heading: heading || 0,
              alt_ft,
              aircraftType: icao,
              wakeCat,
              targetLon: lon,
              targetLat: lat
            },
            geometry: {
              type: 'Point',
              coordinates: [lon, lat, ftToMeters(alt_ft)]
            }
          };

          aircraftFeatures[callsign] = feature;

          // Only create a trail if the aircraft is moving or speed unknown
          if (!isStopped) {
            trailFeatures[callsign] = {
              type: 'Feature',
              properties: {
                callsign,
                alt_ft,
                aircraftType: icao,
                wakeCat
              },
              geometry: {
                type: 'LineString',
                coordinates: [[lon, lat, ftToMeters(alt_ft)]]
              }
            };
          }
        } else {
          feature.properties.targetLon = lon;
          feature.properties.targetLat = lat;
          feature.properties.heading = heading || 0;
          feature.properties.alt_ft = alt_ft;

          let trail = trailFeatures[callsign];

          if (isStopped) {
            // GS=0: mark time we stopped, but don't fade yet
            if (stoppedSinceFrame[callsign] == null) {
              stoppedSinceFrame[callsign] = replayIndex;
            }
            if (trail) {
              trail.properties.alt_ft = alt_ft;
            }
          } else {
            // Moving again: cancel any "stopped" tracking and fade flag
            if (stoppedSinceFrame[callsign] != null) {
              delete stoppedSinceFrame[callsign];
            }

            if (!trail) {
              const icao = aircraftTypes[callsign] || '';
              const wakeCat = getWakeCategory(icao);
              trail = {
                type: 'Feature',
                properties: {
                  callsign,
                  alt_ft,
                  aircraftType: icao,
                  wakeCat
                },
                geometry: {
                  type: 'LineString',
                  coordinates: [[lon, lat, ftToMeters(alt_ft)]]
                }
              };
              trailFeatures[callsign] = trail;
            } else {
              const coords = trail.geometry.coordinates;
              const newCoord = [lon, lat, ftToMeters(alt_ft)];

              if (coords.length === 0) {
                coords.push(newCoord);
              } else {
                const lastCoord = coords[coords.length - 1];
                const stepDist = distanceNm(lastCoord[1], lastCoord[0], newCoord[1], newCoord[0]);
                if (stepDist >= MIN_POINT_SPACING_NM) {
                  coords.push(newCoord);
                }
              }

              if (!keepAllTrails) {
                let pathNm = 0;
                for (let i = coords.length - 1; i > 0; i--) {
                  pathNm += distanceNm(
                    coords[i][1], coords[i][0],
                    coords[i - 1][1], coords[i - 1][0]
                  );
                }

                while (pathNm > maxTrailHistoryNm && coords.length > 1) {
                  const segDist = distanceNm(
                    coords[1][1], coords[1][0],
                    coords[0][1], coords[0][0]
                  );
                  coords.shift();
                  pathNm -= segDist;
                }
              }

              trail.properties.alt_ft = alt_ft;
              trail.properties.fading = false; // moving again
            }
          }
        }

        aircraftLastSeen[callsign] = replayIndex;

        // Update 3D discrete only if 3D view enabled
        if (is3DView) {
          updateAircraftObjectForEvent(ev);
          updateTrailLineForCallsign(callsign);
        }
      });

      // After processing this frame, handle GS=0 timeout -> start slow fade
      for (const cs in stoppedSinceFrame) {
        const since = stoppedSinceFrame[cs];
        if (since == null) continue;
        if (replayIndex - since > STOP_FRAMES_BEFORE_FADE) {
          startTrailFade(cs, 'gs0'); // slow GS0 fade
          delete stoppedSinceFrame[cs];
        }
      }

      replayIndex++;

      // Despawn and fade-on-timeout (normal fade speed)
      for (const cs in aircraftFeatures) {
        const last = aircraftLastSeen[cs];
        if (last == null) continue;

        if (replayIndex - last > DESPAWN_FRAMES) {
          delete aircraftFeatures[cs];
          delete aircraftLastSeen[cs];
          delete stoppedSinceFrame[cs];

          const mesh = threeLayer.aircraftObjects && threeLayer.aircraftObjects.get(cs);
          if (mesh && threeLayer.scene) {
            threeLayer.scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
            threeLayer.aircraftObjects.delete(cs);
          }

          if (!keepAllTrails) {
            startTrailFade(cs, 'timeout'); // normal timeout fade
          }
        }
      }

      // Fade trails from the back
      if (!keepAllTrails) {
        for (const cs in trailFeatures) {
          const trail = trailFeatures[cs];
          if (!trail.properties || !trail.properties.fading) continue;

          const coords = trail.geometry && trail.geometry.coordinates;
          if (!coords || coords.length <= 1) {
            delete trailFeatures[cs];
            if (is3DView) updateTrailLineForCallsign(cs);
            continue;
          }

          const reason = trail.properties.fadeReason || 'other';
          let remainingToRemove = (reason === 'gs0')
            ? TRAIL_FADE_STEP_NM_GS0
            : TRAIL_FADE_STEP_NM_TIMEOUT;

          while (remainingToRemove > 0 && coords.length > 1) {
            const segNm = distanceNm(
              coords[1][1], coords[1][0],
              coords[0][1], coords[0][0]
            );

            if (segNm <= remainingToRemove) {
              coords.shift();
              remainingToRemove -= segNm;
            } else {
              const r = remainingToRemove / segNm;
              coords[0][0] = coords[0][0] + (coords[1][0] - coords[0][0]) * r;
              coords[0][1] = coords[0][1] + (coords[1][1] - coords[0][1]) * r;
              coords[0][2] = coords[0][2] + (coords[1][2] - coords[0][2]) * r;
              remainingToRemove = 0;
            }
          }

          if (coords.length <= 1) {
            delete trailFeatures[cs];
          }

          if (is3DView) updateTrailLineForCallsign(cs);
        }
      }

      needsRender = true;
    }

    // Jump to a specific frame
    function jumpToFrame(targetIndex) {
      if (!maxFrames) return;
      targetIndex = Math.max(0, Math.min(maxFrames - 1, targetIndex));

      clearReplayVisualState();
      replayIndex = 0;

      for (let i = 0; i <= targetIndex && replayIndex < maxFrames; i++) {
        applyFrameStep();
      }

      ensureReplayLayers();
      updateMapSources();
      applyAltitudeFilter();
      updateTimelineUI();
      rebuildAll3DGeometry();
      update3DVisibility();
      applyHideIconsVisualState();
    }

    // 3D buildings on flat 2D map
    function add3DBuildings() {
      if (map.getLayer('3d-buildings')) return;

      const style = map.getStyle();
      if (!style || !style.layers) return;
      const layers = style.layers;
      let labelLayerId;
      for (let i = 0; i < layers.length; i++) {
        const layer = layers[i];
        if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
          labelLayerId = layer.id;
          break;
        }
      }

      if (!labelLayerId) return;

      map.addLayer(
        {
          id: '3d-buildings',
          source: 'composite',
          'source-layer': 'building',
          filter: ['==', 'extrude', 'true'],
          type: 'fill-extrusion',
          minzoom: 15,
          paint: {
            'fill-extrusion-color': '#a3b3c2',
            'fill-extrusion-height': [
              'interpolate', ['linear'], ['zoom'],
              15, ['get', 'height'],
              16, ['*', ['get', 'height'], 1.5]
            ],
            'fill-extrusion-base': ['get', 'min_height'],
            'fill-extrusion-opacity': 0.6
          }
        },
        labelLayerId
      );
    }

    // Hide labels (for dark unlabeled)
    function hideAllLabels() {
      const style = map.getStyle();
      if (!style || !style.layers) return;

      style.layers.forEach(layer => {
        if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
          try {
            map.setLayoutProperty(layer.id, 'visibility', 'none');
          } catch (e) {
            // ignore
          }
        }
      });
    }

    // Show labels again (for normal dark / satellite)
    function showAllLabels() {
      const style = map.getStyle();
      if (!style || !style.layers) return;

      style.layers.forEach(layer => {
        if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
          try {
            map.setLayoutProperty(layer.id, 'visibility', 'visible');
          } catch (e) {
            // ignore
          }
        }
      });
    }

    map.on('style.load', () => {
      // Sky for nicer tilted look
      if (!map.getLayer('sky')) {
        map.addLayer({
          id: 'sky',
          type: 'sky',
          paint: { 'sky-type': 'atmosphere' }
        });
      }

      add3DBuildings();
      loadPlaneIcon();
      ensureReplayLayers();
      updateMapSources();

      applyAltitudeFilter();
      updateTrailColor();
      applyHideIconsVisualState();

      if (!map.getLayer('three-radar')) {
        map.addLayer(threeLayer);
      }

      rebuildAll3DGeometry();
      update3DVisibility();

      // Apply label visibility based on current theme
      if (currentTheme === THEME.UNLABELED) {
        hideAllLabels();
      } else {
        showAllLabels();
      }

      if (!mapInitializedOnce) {
        setStatus(REPLAY_STATE.IDLE, 'Ready. Load an OBS log to begin.');
        mapInitializedOnce = true;
      }

      if (animationRunning && !isPaused) {
        requestAnimationFrame(animate);
      }
    });

    function parseEuroScopeOBS(text) {
      const lines = text.split(/\r?\n/);
      const types = {};
      const lastPos = {};
      const framesLocal = [];
      const firstPositions = {};
      let frameIndexLocal = 0;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        if (trimmed.startsWith('$FP')) {
          const p = trimmed.split(':');
          if (p.length >= 4) {
            const fpTag = p[0];
            const callsign = fpTag.substring(3);
            const equip = p[3];
            const icao = equip.split('/')[0];
            if (callsign && icao) {
              types[callsign] = icao;
            }
          }
          continue;
        }

        if (!trimmed.startsWith('@N:')) continue;

        const p = trimmed.split(':');
        if (p.length < 7) continue;

        const callsign = p[1];
        const lat = parseFloat(p[4]);
        const lon = parseFloat(p[5]);
        const alt_ft = parseFloat(p[6]);
        const gs_kt = p.length > 7 ? parseFloat(p[7]) : NaN;

        if (isNaN(lat) || isNaN(lon) || isNaN(alt_ft)) continue;

        let heading = 0;
        if (lastPos[callsign]) {
          const lp = lastPos[callsign];
          heading = computeBearing(lp.lat, lp.lon, lat, lon);
          if (!isFinite(heading) ||
              (Math.abs(lat - lp.lat) < 1e-5 && Math.abs(lon - lp.lon) < 1e-5)) {
            heading = lp.heading;
          }
        }

        lastPos[callsign] = { lat, lon, heading };

        const event = {
          frameIndex: frameIndexLocal,
          callsign,
          lat,
          lon,
          alt_ft,
          heading,
          gs_kt
        };

        if (!framesLocal[frameIndexLocal]) framesLocal[frameIndexLocal] = [];
        framesLocal[frameIndexLocal].push(event);

        if (!firstPositions[callsign]) {
          firstPositions[callsign] = [lon, lat];
        }

        frameIndexLocal++;
      }

      return {
        frames: framesLocal,
        types,
        maxFrameIndex: frameIndexLocal,
        firstPositions: Object.values(firstPositions)
      };
    }

    fileInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = evt => {
        const text = evt.target.result;
        const parsed = parseEuroScopeOBS(text);

        if (!parsed.frames.length) {
          alert('No @N position packets found in this file.');
          return;
        }

        animationRunning = false;
        isPaused = false;
        frames = parsed.frames;
        aircraftTypes = parsed.types || {};
        maxFrames = parsed.maxFrameIndex;

        clearReplayVisualState();
        replayIndex = 0;

        if (map.getLayer('aircraft-layer')) map.removeLayer('aircraft-layer');
        if (map.getSource('aircraft')) map.removeSource('aircraft');
        if (map.getLayer('trail-layer')) map.removeLayer('trail-layer');
        if (map.getSource('trails')) map.removeSource('trails');

        toggleTrailsBtn.disabled = false;
        playPauseBtn.disabled = false;
        playPauseText.textContent = 'Pause';
        playPauseDot.classList.remove('stopped', 'paused');
        toggleTrailsText.textContent = 'Hide trails';

        if (parsed.firstPositions.length) {
          const bounds = parsed.firstPositions.reduce((b, coord) => {
            return b.extend(coord);
          }, new mapboxgl.LngLatBounds(parsed.firstPositions[0], parsed.firstPositions[0]));
          map.fitBounds(bounds, { padding: 120, maxZoom: 9 });
        }

        timelineRange.disabled = false;
        updateTimelineUI();

        animationRunning = true;
        isPaused = false;
        setStatus(REPLAY_STATE.PLAYING, 'Replaying radar data‚Ä¶');
        requestAnimationFrame(animate);
      };
      reader.readAsText(file);
    });

    function animate() {
      if (!animationRunning || replayIndex >= maxFrames) {
        setStatus(REPLAY_STATE.IDLE, 'Replay finished. Load another file to play again.');
        animationRunning = false;
        return;
      }

      if (isPaused) {
        requestAnimationFrame(animate);
        return;
      }

      const framesToAdvance = Math.max(1, Math.min(8, Math.round(playbackSpeed)));

      for (let step = 0; step < framesToAdvance && replayIndex < maxFrames; step++) {
        applyFrameStep();
      }

      const baseAlpha = 0.01;
      const smoothAlpha = Math.min(0.7, baseAlpha * playbackSpeed);

      // Smooth 2D + 3D positions
      for (const cs in aircraftFeatures) {
        const f = aircraftFeatures[cs];
        const coords = f.geometry.coordinates;
        if (!coords || coords.length < 2) continue;

        const targetLon = f.properties.targetLon;
        const targetLat = f.properties.targetLat;
        if (targetLon == null || targetLat == null) continue;

        const curLon = coords[0];
        const curLat = coords[1];

        const newLon = curLon + (targetLon - curLon) * smoothAlpha;
        const newLat = curLat + (targetLat - curLat) * smoothAlpha;
        const newAlt = ftToMeters(f.properties.alt_ft || 0);

        coords[0] = newLon;
        coords[1] = newLat;
        coords[2] = newAlt;

        const trail = trailFeatures[cs];
        if (trail && trail.geometry && Array.isArray(trail.geometry.coordinates)) {
          const tcoords = trail.geometry.coordinates;
          if (tcoords.length > 0) {
            const lastIdx = tcoords.length - 1;
            tcoords[lastIdx][0] = newLon;
            tcoords[lastIdx][1] = newLat;
            tcoords[lastIdx][2] = newAlt;
          }
        }

        if (is3DView) {
          const evFor3D = {
            callsign: cs,
            lat: newLat,
            lon: newLon,
            alt_ft: f.properties.alt_ft || 0,
            heading: f.properties.heading || 0
          };
          updateAircraftObjectForEvent(evFor3D);
          updateTrailLineForCallsign(cs);
        }
      }

      needsRender = true;

      const now = performance.now();
      if (needsRender && now - lastRenderTime >= RENDER_INTERVAL_MS) {
        ensureReplayLayers();
        updateMapSources();
        applyAltitudeFilter();
        updateTimelineUI();

        lastRenderTime = now;
        needsRender = false;
      }

      requestAnimationFrame(animate);
    }

    // === Theme switching ===
    function updateThemeButtons() {
      btnViewDark.classList.toggle('active', currentTheme === THEME.DARK);
      btnViewSatellite.classList.toggle('active', currentTheme === THEME.SATELLITE);
      btnViewUnlabeled.classList.toggle('active', currentTheme === THEME.UNLABELED);
    }

    function setTheme(theme) {
      if (currentTheme === theme) return;

      currentTheme = theme;
      updateThemeButtons();

      const targetBaseStyleUrl =
        currentTheme === THEME.SATELLITE
          ? 'mapbox://styles/mapbox/satellite-v9'
          : 'mapbox://styles/mapbox/dark-v11'; // DARK and UNLABELED share dark style

      if (targetBaseStyleUrl !== currentBaseStyleUrl) {
        currentBaseStyleUrl = targetBaseStyleUrl;
        map.setStyle(targetBaseStyleUrl);
        // labels handled on style.load
      } else {
        // same base style; flip labels in-place
        if (currentTheme === THEME.UNLABELED) {
          hideAllLabels();
        } else {
          showAllLabels();
        }
      }
    }

    btnViewDark.addEventListener('click', () => setTheme(THEME.DARK));
    btnViewSatellite.addEventListener('click', () => setTheme(THEME.SATELLITE));
    btnViewUnlabeled.addEventListener('click', () => setTheme(THEME.UNLABELED));

    // === UI handlers ===

    toggleTrailsBtn.addEventListener('click', () => {
      trailsVisible = !trailsVisible;

      applyHideIconsVisualState();
      update3DVisibility();

      toggleTrailsText.textContent = trailsVisible ? 'Hide trails' : 'Show trails';
    });

    keepAllTrailsBtn.addEventListener('click', () => {
      keepAllTrails = !keepAllTrails;
      updateKeepAllTrailsButton();
      const state = animationRunning
        ? (isPaused ? REPLAY_STATE.PAUSED : REPLAY_STATE.PLAYING)
        : REPLAY_STATE.IDLE;
      setStatus(
        state,
        keepAllTrails ? 'All trails will be kept for the full replay.' :
                        `Trail length limited to ${maxTrailHistoryNm} NM`
      );
    });

    toggleHideIconsBtn.addEventListener('click', () => {
      hideIcons = !hideIcons;
      toggleHideIconsText.textContent = hideIcons ? 'Hide icons: on' : 'Hide icons: off';
      applyHideIconsVisualState();
    });

    applyTrailLengthBtn.addEventListener('click', () => {
      const v = parseFloat(trailLengthInput.value);
      if (!isNaN(v) && v > 0) {
        maxTrailHistoryNm = v;
        const state = animationRunning
          ? (isPaused ? REPLAY_STATE.PAUSED : REPLAY_STATE.PLAYING)
          : REPLAY_STATE.IDLE;
        setStatus(state, `Trail length set to ${maxTrailHistoryNm} NM`);
      }
    });

    trailLengthInput.addEventListener('change', () => {
      applyTrailLengthBtn.click();
    });

    applyAltBtn.addEventListener('click', () => {
      const newMin = parseInt(minAltInput.value, 10);
      const newMax = parseInt(maxAltInput.value, 10);

      minAlt = isNaN(newMin) ? 0 : newMin;
      maxAlt = isNaN(newMax) ? 45000 : newMax;

      if (minAlt > maxAlt) {
        const tmp = minAlt;
        minAlt = maxAlt;
        maxAlt = tmp;
        minAltInput.value = minAlt;
        maxAltInput.value = maxAlt;
      }

      applyAltitudeFilter();
      update3DVisibility();
      const state = animationRunning
        ? (isPaused ? REPLAY_STATE.PAUSED : REPLAY_STATE.PLAYING)
        : REPLAY_STATE.IDLE;
      setStatus(state, `Replay filtered: ${minAlt}‚Äì${maxAlt} ft`);
    });

    playPauseBtn.addEventListener('click', () => {
      if (!animationRunning && replayIndex >= maxFrames) return;
      if (!maxFrames) return;

      isPaused = !isPaused;
      playPauseText.textContent = isPaused ? 'Play' : 'Pause';

      if (isPaused) {
        setStatus(REPLAY_STATE.PAUSED, 'Replay paused.');
      } else {
        setStatus(REPLAY_STATE.PLAYING, 'Replaying radar data‚Ä¶');
      }
    });

    speedRange.addEventListener('input', () => {
      playbackSpeed = parseFloat(speedRange.value);
      const display = playbackSpeed.toFixed(2).replace(/\.00$/, '');
      speedLabel.textContent = display + 'x';
    });

    trailColorInput.addEventListener('input', () => {
      trailColor = trailColorInput.value;
      updateTrailColor();

      if (threeLayer && threeLayer.trailLines && is3DView) {
        threeLayer.trailLines.forEach((line, cs) => {
          updateTrailLineForCallsign(cs);
        });
      }
    });

    toggle3DViewBtn.addEventListener('click', () => {
      is3DView = !is3DView;
      toggle3DViewText.textContent = is3DView ? '3D mode' : '2D mode';

      map.easeTo({
        pitch: is3DView ? 60 : 0,
        bearing: is3DView ? -24 : 0,
        duration: 600
      });

      if (is3DView) {
        rebuildAll3DGeometry();
      }

      applyHideIconsVisualState();
      update3DVisibility();
    });

    function updateControlsToggle() {
      if (controlsVisible) {
        toolbar.style.display = 'flex';
        controlsToggleText.textContent = 'Hide controls';
        controlsToggleIcon.style.background = '#22c55e';
      } else {
        toolbar.style.display = 'none';
        controlsToggleText.textContent = 'Menu';
        controlsToggleIcon.style.background = '#9ca3af';
      }
    }

    controlsToggle.addEventListener('click', () => {
      controlsVisible = !controlsVisible;
      updateControlsToggle();
    });

    // Timeline scrubbing
    timelineRange.addEventListener('input', () => {
      if (timelineRange.disabled || !maxFrames) return;
      isScrubbing = true;
      isPaused = true;
      playPauseText.textContent = 'Play';
      setStatus(REPLAY_STATE.PAUSED, 'Scrubbing timeline‚Ä¶');
      const idx = parseInt(timelineRange.value, 10) || 0;
      timelineLabel.textContent = `${idx} / ${maxFrames ? maxFrames - 1 : 0}`;
    });

    timelineRange.addEventListener('change', () => {
      if (!maxFrames) return;
      const idx = parseInt(timelineRange.value, 10) || 0;
      jumpToFrame(idx);
      isScrubbing = false;
    });

    // Initial UI state
    updateThemeButtons();
    updateControlsToggle();
    updateKeepAllTrailsButton();
    updateTimelineUI();
  </script>
</body>
</html>
